// -*- C++ -*-
//
// bianca giovanardi
// (c) 2021 all rights reserved
//


// code guard
#if !defined(pyre_algebra_Tensor_icc)
#error this file contains implementation details for pyre::algebra::Tensor
#else


template <typename T, class packingT, int... I>
constexpr pyre::algebra::Tensor<T, packingT, I...>::Tensor() : _data()
{
    // initialize memory
    reset();

    // all done
    return;
}

template <typename T, class packingT, int... I>
constexpr pyre::algebra::Tensor<T, packingT, I...>::Tensor(const data_t & data) 
    : _data(data) {}

template <typename T, class packingT, int... I>
constexpr pyre::algebra::Tensor<T, packingT, I...>::Tensor(const data_t && data) 
    : _data(std::forward(data)) {}

template <typename T, class packingT, int... I>
template <class... T2>
constexpr pyre::algebra::Tensor<T, packingT, I...>::Tensor(T2... args) 
    requires(sizeof...(T2) == S) 
    : Tensor()
{
    // initialize with input arguments
    _initialize(std::make_index_sequence<S> {}, args...);

    // all done
    return;
}

template <typename T, class packingT, int... I>
constexpr pyre::algebra::Tensor<T, packingT, I...>::~Tensor() {}

template <typename T, class packingT, int... I>
constexpr const T &
pyre::algebra::Tensor<T, packingT, I...>::operator[](index_t i) const
{
    // get the offset that corresponds to this {index}
    auto offset = _layout[i];
    // get and return the value
    return _data.at(offset);
}

template <typename T, class packingT, int... I>
constexpr T &
pyre::algebra::Tensor<T, packingT, I...>::operator[](index_t i)
{
    // get the offset that corresponds to this {index}
    auto offset = _layout[i];
    // get and return the value
    return _data.at(offset);
}

template <typename T, class packingT, int... I>
constexpr const T &
pyre::algebra::Tensor<T, packingT, I...>::operator[](int i) const
{
    return _data.at(i);
}

template <typename T, class packingT, int... I>
constexpr T &
pyre::algebra::Tensor<T, packingT, I...>::operator[](int i)
{
    return _data.at(i);
}

template <typename T, class packingT, int... I>
constexpr void
pyre::algebra::Tensor<T, packingT, I...>::operator+=(const Tensor<T, packingT, I...> & rhs)
{
    // helper function (component-wise)
    constexpr auto _operator_plus_equal = []<size_t... J>(Tensor<T, packingT, I...> & data,
        const Tensor<T, packingT, I...> & rhs, std::index_sequence<J...>)
    {
        // component-wise operator+=
        ((data[J] += rhs[J]), ...);

        // all done
        return;
    };

    // component-wise operator+=
    return _operator_plus_equal(_data, rhs, std::make_index_sequence<S> {});
}

template <typename T, class packingT, int... I>
constexpr pyre::algebra::Tensor<T, packingT, I...>::operator T() const requires(S == 1)
{
    return _data[0];
}

template <typename T, class packingT, int... I>
constexpr pyre::algebra::Tensor<T, packingT, I...>::operator data_t() const
{
    return _data;
}

template <typename T, class packingT, int... I>
constexpr auto pyre::algebra::Tensor<T, packingT, I...>::begin() const
{
    return _layout.begin();
}

template <typename T, class packingT, int... I>
constexpr auto pyre::algebra::Tensor<T, packingT, I...>::end() const
{
    return _layout.end();
}

template <typename T, class packingT, int... I>
constexpr void pyre::algebra::Tensor<T, packingT, I...>::reset()
{
    // reset to zero all entries
    return _reset(std::make_index_sequence<S> {});
}

template <typename T, class packingT, int... I>
constexpr auto pyre::algebra::Tensor<T, packingT, I...>::shape() const
{
    return vector_t<N, int>{I...};
}

template <typename T, class packingT, int... I>
constexpr bool pyre::algebra::Tensor<T, packingT, I...>::is_symmetric() const
{
    return std::is_same_v<packingT, pyre::grid::symmetric_t<N>> 
        || std::is_same_v<packingT, pyre::grid::diagonal_t<N>>;
}

template <typename T, class packingT, int... I>
constexpr bool pyre::algebra::Tensor<T, packingT, I...>::is_diagonal() const
{
    return std::is_same_v<packingT, pyre::grid::diagonal_t<N>>;
}

template <typename T, class packingT, int... I>
template <size_t... J, class... T2>
constexpr void
pyre::algebra::Tensor<T, packingT, I...>::_initialize(std::index_sequence<J...>, T2... args)
{
    ((_data[J] = args), ...);

    // all done
    return;
}

template <typename T, class packingT, int... I>
template <size_t... J>
constexpr void pyre::algebra::Tensor<T, packingT, I...>::_reset(std::index_sequence<J...>)
{
    ((_data[J] = T()), ...);

    // all done
    return;
}

template <typename T, class packingT, int... I>
template <size_t... J>
constexpr pyre::algebra::Tensor<T, packingT, I...> 
pyre::algebra::Tensor<T, packingT, I...>::_make_zeros(std::index_sequence<J...>)
{
    constexpr auto wrap = []<size_t>() consteval->T { return 0; };
    return pyre::algebra::Tensor<T, packingT, I...>(wrap.template operator()<J>()...);
}

template <typename T, class packingT, int... I>
template <size_t... J>
constexpr pyre::algebra::Tensor<T, packingT, I...> 
pyre::algebra::Tensor<T, packingT, I...>::_make_ones(std::index_sequence<J...>)
{
    constexpr auto wrap = []<size_t>() consteval->T { return 1; };
    return pyre::algebra::Tensor<T, packingT, I...>(wrap.template operator()<J>()...);
}

template <typename T, class packingT, int... I>
template <size_t... J>
constexpr pyre::algebra::Tensor<T, packingT, I...> 
pyre::algebra::Tensor<T, packingT, I...>::_make_basis_element(
    pyre::algebra::Tensor<T, packingT, I...>::index_t K, std::index_sequence<J...>)
{
    constexpr auto delta = [](size_t II, size_t JJ) ->T 
    { 
        if (II == JJ) return 1; 
        return 0;
    };
    // fill tensor with delta_ij
    return pyre::algebra::Tensor<T, packingT, I...>(delta(_layout[K] /* I */, J)...);
}

template <typename T, class packingT, int... I>
template<typename... Args>
constexpr pyre::algebra::Tensor<T, packingT, I...> 
pyre::algebra::Tensor<T, packingT, I...>::unit(Args... args) requires (sizeof...(Args) == N)
{
    pyre::algebra::Tensor<T, packingT, I...>::index_t K(args...);

    // return K-th basis element tensor
    return pyre::algebra::Tensor<T, packingT, I...>::_make_basis_element(K, 
        std::make_index_sequence<pyre::algebra::Tensor<T, packingT, I...>::size> {});
}


#endif

// end of file
