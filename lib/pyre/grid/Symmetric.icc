// -*- c++ -*-
//
// bianca giovanardi
// (c) 2021 all rights reserved


// code guard
#if !defined(pyre_grid_Symmetric_icc)
#error this file contains implementation details for pyre::grid::Symmetric
#else


// metamethods

// constructor that assumes that the physical layout corresponds to the parameters given and
// infers the nudge
template <int N, template <typename, std::size_t> class containerT>
constexpr
pyre::grid::Symmetric<N, containerT>::
Symmetric(shape_const_reference shape, index_const_reference origin, order_const_reference order) :
    _shape { shape },
    _order { order },
    _origin { origin },
    _D { _shape[0] /* TOFIX */ },
    // compute the nudge, defined as the negative offset of the origin
    _nudge { - _initShift(_origin) }
{}


// interface
// accessors for the user supplied information
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
shape() const -> shape_type
{
    // easy enough
    return _shape;
}


template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
order() const -> order_type
{
    // easy enough
    return _order;
}


template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
origin() const -> index_type
{
    // easy enough
    return _origin;
}


template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
nudge() const -> difference_type
{
    // easy enough
    return _nudge;
}

// TOFIX: The following functions can be free functions. Where do they belong?
namespace{

    template<int N>
    constexpr int _entries(int D) requires (N == 1)
    {
        return D;
    }

    template<int N>
    constexpr int _entries(int D) requires (N > 1)
    {
        int sum_entries = 0;
        for (int i = 0; i < D; ++i)
        {
            sum_entries += _entries<N - 1>(D - i);
        }

        return sum_entries;
    }

    template<int N>
    constexpr int _entriesBeforeRow(int i, int D)
    {
        int result = 0;
        for (int a = 0; a < i; ++a)
        {
            result += _entries<N - 1>(D - a);
        }
        return result;
    }

    template<int N> 
    constexpr int _offset(int D, int i) requires (N == 1)
    {
        return i;
    }

    template<int N, class... T> 
    constexpr int _offset(int D, int i, T... j) requires (sizeof...(T) == N - 1 && N > 1)
    {
        return _entriesBeforeRow<N>(i, D) + _offset<N - 1>(D - i, j...);
    }
}

template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
cells() const -> std::size_t
{
    // the number of cells in the upper- (or lower-) diagonal part
    return _entries<N>(_D);
}


// from {difference_type} to {index_type}
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
index(difference_type offset) const -> index_type
{
    // start from the top
    int K = _D - 1;

    // count the number of matrix entries before row K
    while (offset < _entriesBeforeRow<N>(K, _D)) {
        K--;
    }

    int I = K;
    int J = offset - _entriesBeforeRow<N>(I, _D) + I;

    // shift it by {_origin} and return it
    // TOFIX: not sure if the _origin is used in this way for a symmetric packing
    return index_type{I, J} + _origin;
}


// from {index_type} to {difference_type}
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
offset(index_const_reference index) const -> difference_type
{
    // sort the indices 
    index_type sorted_index = index;
    std::sort(sorted_index.begin(), sorted_index.end());

    // helper function to shift the indices (i, j, k, ...) into (i, j - i, k - j, ...)
    auto _shiftIndices = []<size_t... I>(index_t<N> & idx, std::index_sequence<I...>)
    {
        // iterate in reverse order to avoid overwriting entries before using them
        ((idx[(N - 2 - I) + 1] -= idx[N - 2 - I]), ... );
        // all done
        return;
    };

    // shift the indices (i, j, k, ...) into (i, j - i, k - j, ...)
    _shiftIndices(sorted_index, std::make_index_sequence<N-1> {});

    // helper function needed to expand the array in a parameter pack
    auto _getOffset = []<size_t... I>(index_t<N> idx, int D, std::index_sequence<I...>)
    {
        return _offset<N>(D, idx[I]...);
    };

    // get the offset
    // TOFIX: not sure if the nudge is used in this way for a symmetric packing
    return _nudge + _getOffset(sorted_index, _D, std::make_index_sequence<N> {});
}


// syntactic sugar for the packing isomorphism
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
operator[](difference_type offset) const -> index_type
{
    // easy enough
    return index(offset);
}


template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
operator[](index_const_reference index) const -> difference_type
{
    // easy enough
    return offset(index);
}


// iteration support
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
begin() const -> index_iterator
{
    // make an iterator that generates index in my packing {order}, starting at my {origin}
    return index_iterator(shape(), order(), origin());
}


template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
begin(index_const_reference step) const -> index_iterator
{
    // make an iterator that generates index in my packing {order}, starting at my {origin}
    return index_iterator(shape(), order(), origin(), step);
}


template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
end() const -> index_iterator
{
    // form the end of the container
    auto end = _origin + _shape;
    // build an iterator that points to it
    return index_iterator(_shape, _order, end);
}


// static interface
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
rank() -> int
{
    // easy enough
    return N;
}


// compute the shift necessary so that {origin}, i.e. the smallest index, maps to offset zero
template <int N, template <typename, std::size_t> class containerT>
constexpr auto
pyre::grid::Symmetric<N, containerT>::
_initShift(index_const_reference origin) -> difference_type
{
    // return the offset of {_origin}
    return 0; //TOFIX offset(origin);
}


#endif

// end of file
